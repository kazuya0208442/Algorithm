# 橋の最小切断回数は、最も区間の重なっているところを切れば、どの要望のルートも切断できる。
#  # # # # #
#  @ @ @ @    (1,4)
#    @ @ @ @  (2,5)


#  # # # # # # # # #
#  @ @ @ @ @ @ @ @
#    @ @ @ @ @ @
#      @ @ @
#        @ @ @
#              @ @ @

#区間スケジューリング問題とは以下のような問題である:
# M 個の区間が与えられ、どの 2 つの区間も時間帯を共有しないように最大個数の区間を選べ
# まず区間スケジューリング問題の答えが k 個だった場合、その k 個は時間帯を共有しないので、それらを全部刺すには最低でも k 本の串が必要である (弱双対性)
# 逆に k 本の串があれば十分であることは、区間スケジューリング問題に対する貪欲法の動きを注意深く追うと理解することができる。具体的には、
# 区間スケジューリング問題で選ぶ k 個の区間に対して、その右端から串を刺していけば、ちょうど k 本の串ですべての区間を串刺しにできる (強双対性)



N, M = map(int, input().split())
bridge = sorted([list(map(int, input().split())) for _ in range(M)], key=lambda x: x[1])
r = 0
ans = 0

for i in range(M):
    if r <= bridge[i][0]:
        r = bridge[i][1]
        ans += 1

print(ans)



# 右端 r = 0 とする。右端rの左側を切断する。
# 次の区間の左端が　l < r だったら、それは切断されている。
#  0 1 2 3 4  
#    @ @ @        [1,3]   r = 3
#      @ @ @      [2,4]   l = 2

# r <= l なら、まだ切断されていない区間なので、rをその区間の右端に更新する。
#  0 1 2 3 4 5
#    @ @ @        [1,3]   r = 3
#        @ @ @      [3,5]   l = 3

