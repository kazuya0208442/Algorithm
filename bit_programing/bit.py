# https://qiita.com/gogotealove/items/11f9e83218926211083a
# 「n 個の選択肢それぞれに Yes or No の二択があるが、その部分集合（選択できるパターン）の全てを網羅的にチェックしたい」といった場合に使えます。Yes or No の二択が n 箇所あるので、パターン数は 2n2n になります。（何も選ばないという選択肢もパターンに含まれます）
# この選択肢の1つ1つを2進数の bit に見立ててシフト演算でチェックを行うことから「bit 全探索」とも呼ばれますが、やっていることは単なる全探索です。


# みかん（100円）りんご（200円）ぶどう（300円）がそれぞれ1つずつ果物屋さんにありました。財布の中には300円ありますが、考え得るすべての買い物パターンを列挙しなさい。
# 全ての買い物パターンで合計金額を計算し、その中から300円以下で済んだものを列挙すればよさそうです。全部で 23=823=8 パターンとなりますので、基本的にはこれで for ループを回してチェックを行います。（「何も買わない」「み」「り」「ぶ」「み＋り」「み＋ぶ」「り＋ぶ」「み＋り＋ぶ」の8通りです）

# 10進数表記	2進数表記	      買い物リスト
#    0	           000	   （何も買わない）
#    1	           001	   　　　　　　　　ぶどう
#    2	           010	   　　　　りんご
#    3	           011	   　　　　りんご＋ぶどう
#    4	           100	   みかん
#    5	           101	   みかん　　　　＋ぶどう
#    6	           110	   みかん＋りんご
#    7	           111	   みかん＋りんご＋ぶどう


# 2進数の練習

# x = 5

# print(bin(x))           # 0b101
# print(type(bin(x)))
# print('*'*20)
# print(bin(x >> 0))      # 0b101   # 右シフト
# print(bin(x >> 1))      # 0b10
# print(bin(x >> 2))      # 0b1
# print(bin(x >> 3))      # 0b0
# print(bin(x >> 4))      # 0b0
# print('*'*20)
# print(bin(x << 0))      # 0b101   # 左シフト
# print(bin(x << 1))      # 0b1010
# print(bin(x << 2))      # 0b10100
# print('*'*20)
# print((x >> 0) & 1)      # 0b101  # 1 との論理積。最下位の桁が 1 であるかどうかチェックする
# print((x >> 1) & 1)      # 0b10
# print((x >> 2) & 1)      # 0b1
# print((x >> 3) & 1)      # 0b0
# print((x >> 4) & 1)      # 0b0


# みかん（100円）りんご（200円）ぶどう（300円）がそれぞれ1つずつ果物屋さんにありました。財布の中には300円ありますが、考え得るすべての買い物パターンを列挙しなさい。
# 全ての買い物パターンで合計金額を計算し、その中から300円以下で済んだものを列挙すればよさそうです。全部で 23=823=8 パターンとなりますので、基本的にはこれで for ループを回してチェックを行います。（「何も買わない」「み」「り」「ぶ」「み＋り」「み＋ぶ」「り＋ぶ」「み＋り＋ぶ」の8通りです）


money = 300
items = (('mikan', 100), ('apple', 200), ('grape', 300))
n = len(items)

for i in range(2 ** 3):
    bag = []
    print('pattern {}: '.format(i), end='')  # 次のprint()が改行されずに、同じ行に書かれる。
    for j in range(n):
        if ((i >> j) & 1):
            bag.append(items[j][0])
    print(bag)