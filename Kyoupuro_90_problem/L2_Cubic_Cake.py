# 立方体にするということは、縦、横、高さすべてが同じ長さで、その一片の長さの定数倍で、縦、横、高さが表せるということ。
# つまり、縦、横、高さの最大公約数が一片の長さになる。
# 3つ以上の時は、２個ずつ最大公約数を求めていく。例えば、2**3, 2**4, 2**5 だと、2**3, 2**4の最大公約数は2**3で、2**3と2**5の最大公約数は2**3だね。
# 共通する約数だから、and条件の真ん中の塗りつぶされたところみたいな。

def main():
    A, B, C = map(int, input().split())

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a 
    
    cubic = gcd(gcd(A, B), C)
    cut_num = (A+B+C)/cubic - 3  # cubicの長さで各辺の長さを割ると、cubicの個数が出る。切る回数は、その個数ー１になる。２個あるなら切るのは１回。
                                 # WAが1つ出た、おそらく割り算だ。
    # cut_num = (A / cubic + B / cubic + C / cubic) - 3    # これもあかん同じとこでWA  入力例 (1000000000000000000 999999999999999999 999999999999999998)があかん

    # cut_num = (A+B+C)//cubic - 3     # これで行けたけどなんでだろう。。。。
    print(cubic)
    print(type(cubic))            

    print(A+B+C)                  # 2999999999999999997 <class 'int'>
    print(type(A+B+C))

    print(A+B+C / cubic)          # 3e+18 <class 'float'> 普通に割り算するとfloatになってしまい誤差が出るので、//を使おう。
    print(type(A+B+C / cubic))
    print(int(A+B+C / cubic))     # 3000000000000000000

    print(A+B+C // cubic)         # 2999999999999999997 <class 'int'>
    print(type(A+B+C // cubic))


    print(int(cut_num))           # 3000000000000000000 <class 'int'>

# 切り捨て除算の演算子を使うと、計算結果はintのままなので正確な値となる。
# しかし、（不必要に）浮動小数点の除算をすると、計算結果はfloatになるのでそこでの精度は10進数で約16桁である。17桁よりも少ないので、計算結果を必要な精度で表現できない。 その後でint型にキャストしたとしても、失われた精度は戻らない。直接割った値とは異なる値になってしまう。
# 17桁の数を正確に求めようと思ったら、浮動小数点の除算を経由してはいけないのだ。
                                   

main()                                 




    